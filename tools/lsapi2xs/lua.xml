<?xml version="1.0" encoding="utf-8" ?>
<api-cfg>
    <env ignoreCase="yes" startFunc="(" stopFunc=")" paramSeparator="," terminal=";" additionalWordChar=".:" />
    <autoc language="LUA">
        <keyword name="and" func="no" />
        <keyword name="assert" func="yes">
            <overload retval="void" descr="Issues an error when the value of its argument v is false (i.e., nil or false);&#x0A;
            otherwise, returns all its arguments. message is an error message; when absent, it&#x0A;
            defaults to 'assertion failed!'">
                <param name="bool:v" />
                <param name="string:[message]" />
            </overload>
        </keyword>
        <keyword name="break" func="no" />
        <keyword name="collectgarbage" func="yes">
            <overload retval="void" descr="This function is a generic interface to the garbage collector.&#x0A;
It performs different functions according to its first argument, opt:&#x0A;

&#32;    * 'stop': stops the garbage collector.&#x0A;
&#32;     * 'restart': restarts the garbage collector.&#x0A;
&#32;     * 'collect': performs a full garbage-collection cycle.&#x0A;
&#32;     * 'count': returns the total memory in use by Lua (in Kbytes).&#x0A;
&#32;     * 'step': performs a garbage-collection step. The step 'size' is controlled by arg&#x0A;
&#32;         (larger values mean more steps) in a non-specified way. If you want to control&#x0A;
&#32;         the step size you must experimentally tune the value of arg. Returns true if&#x0A;
&#32;         the step finished a collection cycle.&#x0A;
&#32;     * 'setpause': sets arg as the new value for the pause of the collector.&#x0A;
&#32;         Returns the previous value for pause.&#x0A;
&#32;     * 'setstepmul': sets arg as the new value for the step multiplier of the collector&#x0A;
&#32;         Returns the previous value for step.">
                <param name="string:opt" />
                <param name="[arg]" />
            </overload>
        </keyword>
        <keyword name="coroutine.create" func="yes">
            <overload retval="void" descr="
Creates a new coroutine, with body f. f must be a Lua function. Returns this new&#x0A;
coroutine, an object with type 'thread'.&#x0A;
">
                <param name="function:f" />
            </overload>
        </keyword>
        <keyword name="coroutine.resume" func="yes">
            <overload retval="void" descr="
Starts or continues the execution of coroutine co. The first time you resume a&#x0A;
coroutine, it starts running its body. The values val1, ... are passed as the &#x0A;
arguments to the body function. If the coroutine has yielded, resume restarts it; the &#x0A;
values val1, ... are passed as the results from the yield.&#x0A;&#x0A;
&#x0A;
If the coroutine runs without any errors, resume returns true plus any values passed &#x0A;
to yield (if the coroutine yields) or any values returned by the body function (if the&#x0A;
coroutine terminates). If there is any error, resume returns false plus the error &#x0A;
message.">
                <param name="co" />
                <param name="[, val, ...]" />
            </overload>
        </keyword>
        <keyword name="coroutine.running" func="yes">
            <overload retval="void" descr="
Returns the running coroutine, or nil when called by the main thread. 
        "></overload>
        </keyword>
        <keyword name="coroutine.status" func="yes">
            <overload retval="void" descr="
Returns the status of coroutine co, as a string: 'running', if the coroutine is running (that is, it called status); &#x0A;
'suspended', if the coroutine is suspended in a call to yield, or if it has not started running yet; &#x0A;
'normal' if the coroutine is active but not running (that is, it has resumed another coroutine); and &#x0A;
'dead' if the coroutine has finished its body function, or if it has stopped with an error.">
                <param name="co" />
            </overload>
        </keyword>
        <keyword name="coroutine.wrap" func="yes">
            <overload retval="void" descr="
Creates a new coroutine, with body f. f must be a Lua function. Returns a function that resumes &#x0A;
the coroutine each time it is called. Any arguments passed to the function behave as the extra &#x0A;
arguments to resume. Returns the same values returned by resume, except the first boolean. In &#x0A;
case of error, propagates the error. ">
                <param name="f" />
            </overload>
        </keyword>
        <keyword name="coroutine.yield" func="yes">
            <overload retval="void" descr="
Suspends the execution of the calling coroutine. The coroutine cannot be running a C function, a &#x0A;
metamethod, or an iterator. Any arguments to yield are passed as extra results to resume. 
        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="debug.debug" func="yes">
            <overload retval="void" descr="
Enters an interactive mode with the user, running each string that the user enters. Using &#x0A;
simple commands and other debug facilities, the user can inspect global and local variables, &#x0A;
change their values, evaluate expressions, and so on. A line containing only the word cont &#x0A;
finishes this function, so that the caller continues its execution.&#x0A;
&#x0A;
Note that commands for debug.debug are not lexically nested within any function, and so &#x0A;
have no direct access to local variables. "></overload>
        </keyword>
        <keyword name="debug.getfenv" func="yes">
            <overload retval="void" descr="
Returns the environment of object o. ">
                <param name="o" />
            </overload>
        </keyword>
        <keyword name="debug.gethook" func="yes">
            <overload retval="void" descr="
Returns the current hook settings of the thread, as three values: the current hook function, the &#x0A;
current hook mask, and the current hook count (as set by the debug.sethook function). 
        ">
                <param name="[thread]" />
            </overload>
        </keyword>
        <keyword name="debug.getinfo" func="yes">
            <overload retval="void" descr="
Returns a table with information about a function. You can give the function directly, or you &#x0A;
can give a number as the value of function, which means the function running at level function &#x0A;
of the call stack of the given thread: level 0 is the current function (getinfo itself); level 1 &#x0A;
is the function that called getinfo; and so on. If function is a number larger than the number &#x0A;
of active functions, then getinfo returns nil. &#x0A;

The returned table can contain all the fields returned by lua_getinfo, with the string what &#x0A;
describing which fields to fill in. The default for what is to get all information available, &#x0A;
except the table of valid lines. If present, the option 'f' adds a field named func with the &#x0A;
function itself. If present, the option 'L' adds a field named activelines with the table of &#x0A;
valid lines.&#x0A;
&#x0A;
For instance, the expression debug.getinfo(1,'n').name returns a table with a name for the current &#x0A;
function, if a reasonable name can be found, and the expression debug.getinfo(print) returns a table &#x0A;
with all available information about the print function.">
                <param name="[thread,]" />
                <param name="function" />
                <param name="[, what]" />
            </overload>
        </keyword>
        <keyword name="debug.getlocal" func="yes">
            <overload retval="void" descr="
This function returns the name and the value of the local variable with index local of the function &#x0A;
at level level of the stack. (The first parameter or local variable has index 1, and so on, until the &#x0A;
last active local variable.) The function returns nil if there is no local variable with the given index, &#x0A;
and raises an error when called with a level out of range. (You can call debug.getinfo to check whether &#x0A;
the level is valid.)&#x0A;
&#x0A;
Variable names starting with '(' (open parentheses) represent internal variables (loop control variables, &#x0A;
temporaries, and C function locals). ">
                <param name="[thread,]" />
                <param name="level" />
                <param name="local" />
            </overload>
        </keyword>
        <keyword name="debug.getmetatable" func="yes">
            <overload retval="void" descr="Returns the metatable of the given object or nil if it does not have a metatable.">
                <param name="object" />
            </overload>
        </keyword>
        <keyword name="debug.getregistry" func="yes">
            <overload retval="void" descr="Returns the registry table. "></overload>
        </keyword>
        <keyword name="debug.getupvalue" func="yes">
            <overload retval="void" descr="
This function returns the name and the value of the upvalue with index up of the function &#x0A;
func. The function returns nil if there is no upvalue with the given index. 
        ">
                <param name="func" />
                <param name="up" />
            </overload>
        </keyword>
        <keyword name="debug.setfenv" func="yes">
            <overload retval="void" descr="
Sets the environment of the given object to the given table. Returns object. 
        ">
                <param name="object" />
                <param name="table" />
            </overload>
        </keyword>
        <keyword name="debug.sethook" func="yes">
            <overload retval="void" descr="Sets the given function as a hook. The string mask and the number count describe when the hook &#x0A;
will be called. The string mask may have the following characters, with the given meaning:&#x0A;
&#x0A;
    * 'c': the hook is called every time Lua calls a function;&#x0A;
    * 'r': the hook is called every time Lua returns from a function;&#x0A;
    * 'l': the hook is called every time Lua enters a new line of code.&#x0A;
&#x0A;
With a count different from zero, the hook is called after every count instructions.&#x0A;
&#x0A;
When called without arguments, debug.sethook turns off the hook.&#x0A;
&#x0A;
When the hook is called, its first parameter is a string describing the event that has triggered &#x0A;
its call: 'call', 'return' (or 'tail return', when simulating a return from a tail call), 'line', &#x0A;
and 'count'. For line events, the hook also gets the new line number as its second parameter. &#x0A;
Inside a hook, you can call getinfo with level 2 to get more information about the running function &#x0A;
(level 0 is the getinfo function, and level 1 is the hook function), unless the event is 'tail return'. &#x0A;
In this case, Lua is only simulating the return, and a call to getinfo will return invalid data.">
                <param name="[thread,]" />
                <param name="hook" />
                <param name="mask" />
                <param name="[, count]" />
            </overload>
        </keyword>
        <keyword name="debug.setlocal" func="yes">
            <overload retval="void" descr="This function assigns the value value to the local variable with index local of the function at level &#x0A;
level of the stack. The function returns nil if there is no local variable with the given index, and &#x0A;
raises an error when called with a level out of range. (You can call getinfo to check whether the level &#x0A;
is valid.) Otherwise, it returns the name of the local variable">
                <param name="[thread,]" />
                <param name="level" />
                <param name="local" />
                <param name="value" />
            </overload>
        </keyword>
        <keyword name="debug.setmetatable" func="yes">
            <overload retval="void" descr="
Sets the metatable for the given object to the given table (which can be nil). 
        ">
                <param name="object" />
                <param name="table" />
            </overload>
        </keyword>
        <keyword name="debug.setupvalue" func="yes">
            <overload retval="void" descr="
This function assigns the value value to the upvalue with index up of the function func. The function &#x0A;
returns nil if there is no upvalue with the given index. Otherwise, it returns the name of the upvalue. 
        ">
                <param name="func" />
                <param name="up" />
                <param name="value" />
            </overload>
        </keyword>
        <keyword name="debug.traceback" func="yes">
            <overload retval="void" descr="
Returns a string with a traceback of the call stack. An optional message string is appended at the &#x0A;
beginning of the traceback. An optional level number tells at which level to start the traceback &#x0A;
(default is 1, the function calling traceback). 
        ">
                <param name="[thread,]" />
                <param name="[message]" />
                <param name="[, level]" />
            </overload>
        </keyword>
        <keyword name="do" func="no" />
        <keyword name="dofile" func="yes">
            <overload retval="void" descr="
Opens the named file and executes its contents as a Lua chunk. When called without arguments, dofile &#x0A;
executes the contents of the standard input (stdin). Returns all values returned by the chunk. In case &#x0A;
of errors, dofile propagates the error to its caller (that is, dofile does not run in protected mode). 
        ">
                <param name="filename" />
            </overload>
        </keyword>
        <keyword name="else" func="no" />
        <keyword name="elseif" func="no" />
        <keyword name="end" func="no" />
        <keyword name="error" func="yes">
            <overload retval="void" descr="
Terminates the last protected function called and returns message as the error message. &#x0A;
Function error never returns.&#x0A;
&#x0A;
Usually, error adds some information about the error position at the beginning of the message. &#x0A;
The level argument specifies how to get the error position. With level 1 (the default), the error &#x0A;
position is where the error function was called. Level 2 points the error to where the function &#x0A;
that called error was called; and so on. Passing a level 0 avoids the addition of error position &#x0A;
information to the message. 
        ">
                <param name="message" />
                <param name="[, level]" />
            </overload>
        </keyword>
        <keyword name="false" func="no" />
        <keyword name="file:close" func="yes">
            <overload retval="void" descr="
Closes file. Note that files are automatically closed when their handles are garbage collected, &#x0A;
but that takes an unpredictable amount of time to happen. 
        "></overload>
        </keyword>
        <keyword name="file:flush" func="yes">
            <overload retval="void" descr="
Saves any written data to file. 
        "></overload>
        </keyword>
        <keyword name="file:lines" func="yes">
            <overload retval="void" descr="
Returns an iterator function that, each time it is called, returns a new line from the file. &#x0A;
Therefore, the construction&#x0A;
for line in file:lines() do body end&#x0A;
will iterate over all lines of the file. (Unlike io.lines, this function does not close the file when the loop ends.) 
        "></overload>
        </keyword>
        <keyword name="file:read" func="yes">
            <overload retval="void" descr="
Reads the file file, according to the given formats, which specify what to read. For each format, &#x0A;
the function returns a string (or a number) with the characters read, or nil if it cannot read data &#x0A;
with the specified format. When called without formats, it uses a default format that reads the entire &#x0A;
next line (see below).&#x0A;
&#x0A;
The available formats are&#x0A;
&#x0A;
    * '*n': reads a number; this is the only format that returns a number instead of a string.&#x0A;
    * '*a': reads the whole file, starting at the current position. On end of file, it returns the empty string.&#x0A;
    * '*l': reads the next line (skipping the end of line), returning nil on end of file. This is the default format.&#x0A;
    * number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it &#x0A;
            reads nothing and returns an empty string, or nil on end of file.

        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="file:seek" func="yes">
            <overload retval="void" descr="
Sets and gets the file position, measured from the beginning of the file, to the position given by offset &#x0A;
plus a base specified by the string whence, as follows:&#x0A;
&#x0A;
    * 'set': base is position 0 (beginning of the file);&#x0A;
    * 'cur': base is current position;&#x0A;
    * 'end': base is end of file;&#x0A;

In case of success, function seek returns the final file position, measured in bytes from the beginning of the &#x0A;
file. If this function fails, it returns nil, plus a string describing the error.&#x0A;
&#x0A;
The default value for whence is 'cur', and for offset is 0. Therefore, the call file:seek() returns the &#x0A;
current file position, without changing it; the call file:seek('set') sets the position to the beginning &#x0A;
of the file (and returns 0); and the call file:seek('end') sets the position to the end of the file, and &#x0A;
returns its size. 
        ">
                <param name="[whence]" />
                <param name="[, offset]" />
            </overload>
        </keyword>
        <keyword name="file:setvbuf" func="yes">
            <overload retval="void" descr="
Sets the buffering mode for an output file. There are three available modes:&#x0A;
&#x0A;
    * 'no': no buffering; the result of any output operation appears immediately.&#x0A;
    * 'full': full buffering; output operation is performed only when the buffer is full &#x0A;
            (or when you explicitly flush the file (see io.flush)).&#x0A;
    * 'line': line buffering; output is buffered until a newline is output or there is any input &#x0A;
            from some special files (such as a terminal device).&#x0A;
&#x0A;
For the last two cases, size specifies the size of the buffer, in bytes. The default is an appropriate size. 
        ">
                <param name="mode" />
                <param name="[, size]" />
            </overload>
        </keyword>
        <keyword name="file:write" func="yes">
            <overload retval="void" descr="
Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write &#x0A;
other values, use tostring or string.format before write. 
        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="for" func="no" />
        <keyword name="function" func="no" />
        <keyword name="getfenv" func="yes">
            <overload retval="void" descr="
Returns the current environment in use by the function. f can be a Lua function or a number that specifies &#x0A;
the function at that stack level: Level 1 is the function calling getfenv. If the given function is not a &#x0A;
Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1. 
        ">
                <param name="[f]" />
            </overload>
        </keyword>
        <keyword name="getmetatable" func="yes">
            <overload retval="void" descr="
If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a '__metatable' &#x0A;
field, returns the associated value. Otherwise, returns the metatable of the given object. 
        ">
                <param name="object" />
            </overload>
        </keyword>
        <keyword name="if" func="no" />
        <keyword name="in" func="no" />
        <keyword name="io.close" func="yes">
            <overload retval="void" descr="
Equivalent to file:close(). Without a file, closes the default output file. 
        ">
                <param name="[file]" />
            </overload>
        </keyword>
        <keyword name="io.flush" func="yes">
            <overload retval="void" descr="
Equivalent to file:flush over the default output file. 
        "></overload>
        </keyword>
        <keyword name="io.input" func="yes">
            <overload retval="void" descr="
When called with a file name, it opens the named file (in text mode), and sets its handle as the default &#x0A;
input file. When called with a file handle, it simply sets this file handle as the default input file. When &#x0A;
called without parameters, it returns the current default input file.&#x0A;
&#x0A;
In case of errors this function raises the error, instead of returning an error code. 
        ">
                <param name="[file]" />
            </overload>
        </keyword>
        <keyword name="io.lines" func="yes">
            <overload retval="void" descr="
Opens the given file name in read mode and returns an iterator function that, each time it is called, &#x0A;
returns a new line from the file. Therefore, the construction&#x0A;
&#x0A;
     for line in io.lines(filename) do body end&#x0A;

will iterate over all lines of the file. When the iterator function detects the end of file, it returns &#x0A;
nil (to finish the loop) and automatically closes the file.&#x0A;
&#x0A;
The call io.lines() (with no file name) is equivalent to io.input():lines(); that is, it iterates over &#x0A;
the lines of the default input file. In this case it does not close the file when the loop ends. 
        ">
                <param name="[filename]" />
            </overload>
        </keyword>
        <keyword name="io.open" func="yes">
            <overload retval="void" descr="
This function opens a file, in the mode specified in the string mode. It returns a new file handle, &#x0A;
or, in case of errors, nil plus an error message.&#x0A;
&#x0A;
The mode string can be any of the following:&#x0A;
&#x0A;
    * 'r': read mode (the default);&#x0A;
    * 'w': write mode;&#x0A;
    * 'a': append mode;&#x0A;
    * 'r+': update mode, all previous data is preserved;&#x0A;
    * 'w+': update mode, all previous data is erased;&#x0A;
    * 'a+': append update mode, previous data is preserved, writing is only allowed at the end of file.&#x0A;
&#x0A;
The mode string can also have a 'b' at the end, which is needed in some systems to open the file in &#x0A;
binary mode. This string is exactly what is used in the standard C function fopen. 
        ">
                <param name="filename" />
                <param name="[, mode]" />
            </overload>
        </keyword>
        <keyword name="io.output" func="yes">
            <overload retval="void" descr="
Similar to io.input, but operates over the default output file. 
        ">
                <param name="[file]" />
            </overload>
        </keyword>
        <keyword name="io.popen" func="yes">
            <overload retval="void" descr="
Starts program prog in a separated process and returns a file handle that you can use to read data from &#x0A;
this program (if mode is 'r', the default) or to write data to this program (if mode is 'w').&#x0A;
&#x0A;
This function is system dependent and is not available on all platforms. 
        ">
                <param name="prog" />
                <param name="[, mode]" />
            </overload>
        </keyword>
        <keyword name="io.read" func="yes">
            <overload retval="void" descr="
Equivalent to io.input():read. 
        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="io.tmpfile" func="yes">
            <overload retval="void" descr="
Returns a handle for a temporary file. This file is opened in update mode and it is automatically &#x0A;
removed when the program ends. 
        "></overload>
        </keyword>
        <keyword name="io.type" func="yes">
            <overload retval="void" descr="
Checks whether obj is a valid file handle. Returns the string 'file' if obj is an open file handle, &#x0A;
'closed file' if obj is a closed file handle, or nil if obj is not a file handle. 
        ">
                <param name="obj" />
            </overload>
        </keyword>
        <keyword name="io.write" func="yes">
            <overload retval="void" descr="
Equivalent to io.output():write. 
        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="ipairs" func="yes">
            <overload retval="void" descr="
Returns three values: an iterator function, the table t, and 0, so that the construction&#x0A;
&#x0A;
     for i,v in ipairs(t) do body end&#x0A;
&#x0A;
will iterate over the pairs (1,t[1]), (2,t[2]), ..., up to the first integer key absent from the table. 
        ">
                <param name="t" />
            </overload>
        </keyword>
        <keyword name="load" func="yes">
            <overload retval="void" descr="
Loads a chunk using function func to get its pieces. Each call to func must return a string that &#x0A;
concatenates with previous results. A return of an empty string, nil, or no value signals the end of &#x0A;
the chunk.&#x0A;
&#x0A;
If there are no errors, returns the compiled chunk as a function; otherwise, returns nil plus the error &#x0A;
message. The environment of the returned function is the global environment.&#x0A;
&#x0A;
chunkname is used as the chunk name for error messages and debug information. When absent, &#x0A;
it defaults to '=(load)'. 
        ">
                <param name="func" />
                <param name="[, chunkname]" />
            </overload>
        </keyword>
        <keyword name="loadfile" func="yes">
            <overload retval="void" descr="
Similar to load, but gets the chunk from file filename or from the standard input, &#x0A;
if no file name is given. 
        ">
                <param name="[filename]" />
            </overload>
        </keyword>
        <keyword name="loadstring" func="yes">
            <overload retval="void" descr="
Similar to load, but gets the chunk from the given string.&#x0A;
To load and run a given string, use the idiom&#x0A;
     assert(loadstring(s))()&#x0A;
When absent, chunkname defaults to the given string. 
        ">
                <param name="string" />
                <param name="[, chunkname]" />
            </overload>
        </keyword>
        <keyword name="local" func="no" />
        <keyword name="math.abs" func="yes">
            <overload retval="void" descr="
Returns the absolute value of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.acos" func="yes">
            <overload retval="void" descr="
Returns the arc cosine of x (in radians). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.asin" func="yes">
            <overload retval="void" descr="
Returns the arc sine of x (in radians). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.atan" func="yes">
            <overload retval="void" descr="
Returns the arc tangent of x (in radians). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.atan2" func="yes">
            <overload retval="void" descr="
Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to &#x0A;
find the quadrant of the result. (It also handles correctly the case of x being zero.) 
        ">
                <param name="y" />
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.ceil" func="yes">
            <overload retval="void" descr="
Returns the smallest integer larger than or equal to x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.cos" func="yes">
            <overload retval="void" descr="
Returns the cosine of x (assumed to be in radians). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.cosh" func="yes">
            <overload retval="void" descr="
Returns the hyperbolic cosine of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.deg" func="yes">
            <overload retval="void" descr="
Returns the angle x (given in radians) in degrees. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.exp" func="yes">
            <overload retval="void" descr="
Returns the value ex. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.floor" func="yes">
            <overload retval="void" descr="
Returns the largest integer smaller than or equal to x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.fmod" func="yes">
            <overload retval="void" descr="
Returns the remainder of the division of x by y that rounds the quotient towards zero. 
        ">
                <param name="x" />
                <param name="y" />
            </overload>
        </keyword>
        <keyword name="math.frexp" func="yes">
            <overload retval="void" descr="
Returns m and e such that x = m2e, e is an integer and the absolute value of m is in 
the range [0.5, 1) (or zero when x is zero). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.huge" func="no" />
        <keyword name="math.ldexp" func="yes">
            <overload retval="void" descr="
Returns m2e (e should be an integer). 
        ">
                <param name="m" />
                <param name="e" />
            </overload>
        </keyword>
        <keyword name="math.log" func="yes">
            <overload retval="void" descr="
Returns the natural logarithm of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.log10" func="yes">
            <overload retval="void" descr="
Returns the base-10 logarithm of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.max" func="yes">
            <overload retval="void" descr="
Returns the maximum value among its arguments. 
        ">
                <param name="x" />
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="math.min" func="yes">
            <overload retval="void" descr="
Returns the minimum value among its arguments. 
        ">
                <param name="x" />
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="math.modf" func="yes">
            <overload retval="void" descr="
Returns two numbers, the integral part of x and the fractional part of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.pi" func="no" />
        <keyword name="math.pow" func="yes">
            <overload retval="void" descr="
Returns xy. (You can also use the expression x^y to compute this value.) 
        ">
                <param name="x" />
                <param name="y" />
            </overload>
        </keyword>
        <keyword name="math.rad" func="yes">
            <overload retval="void" descr="
Returns the angle x (given in degrees) in radians. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.random" func="yes">
            <overload retval="void" descr="
This function is an interface to the simple pseudo-random generator function rand &#x0A;
provided by ANSI C. (No guarantees can be given for its statistical properties.)&#x0A;
&#x0A;
When called without arguments, returns a uniform pseudo-random real number in the &#x0A;
range [0,1). When called with an integer number m, math.random returns a uniform &#x0A;
pseudo-random integer in the range [1, m]. When called with two integer numbers m and &#x0A;
n, math.random returns a uniform pseudo-random integer in the range [m, n]. 
        ">
                <param name="[m [, n]]" />
            </overload>
        </keyword>
        <keyword name="math.randomseed" func="yes">
            <overload retval="void" descr="
Sets x as the 'seed' for the pseudo-random generator: equal seeds produce equal 
sequences of numbers. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.sin" func="yes">
            <overload retval="void" descr="
Returns the sine of x (assumed to be in radians). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.sinh" func="yes">
            <overload retval="void" descr="
Returns the hyperbolic sine of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.sqrt" func="yes">
            <overload retval="void" descr="
Returns the square root of x. (You can also use the expression x^0.5 to compute this value.) 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.tan" func="yes">
            <overload retval="void" descr="
Returns the tangent of x (assumed to be in radians). 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="math.tanh" func="yes">
            <overload retval="void" descr="
Returns the hyperbolic tangent of x. 
        ">
                <param name="x" />
            </overload>
        </keyword>
        <keyword name="module" func="yes">
            <overload retval="void" descr="
Creates a module. If there is a table in package.loaded[name], this table is the module. &#x0A;
Otherwise, if there is a global table t with the given name, this table is the module. &#x0A;
Otherwise creates a new table t and sets it as the value of the global name and the value &#x0A;
of package.loaded[name]. This function also initializes t._NAME with the given name, t._M &#x0A;
with the module (t itself), and t._PACKAGE with the package name (the full module name &#x0A;
minus last component; see below). Finally, module sets t as the new environment of the &#x0A;
current function and the new value of package.loaded[name], so that require returns t.&#x0A;
&#x0A;
If name is a compound name (that is, one with components separated by dots), module creates &#x0A;
(or reuses, if they already exist) tables for each component. For instance, if name is a.b.c, &#x0A;
then module stores the module table in field c of field b of global a.&#x0A;
&#x0A;
This function can receive optional options after the module name, where each option is a &#x0A;
function to be applied over the module. 
        ">
                <param name="name" />
                <param name="[, ...]" />
            </overload>
        </keyword>
        <keyword name="next" func="yes">
            <overload retval="void" descr="
Allows a program to traverse all fields of a table. Its first argument is a table and its second &#x0A;
argument is an index in this table. next returns the next index of the table and its associated &#x0A;
value. When called with nil as its second argument, next returns an initial index and its associated &#x0A;
value. When called with the last index, or with nil in an empty table, next returns nil. If the &#x0A;
second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to &#x0A;
check whether a table is empty.&#x0A;
&#x0A;
The order in which the indices are enumerated is not specified, even for numeric indices. (To &#x0A;
traverse a table in numeric order, use a numerical for or the ipairs function.)&#x0A;
&#x0A;
The behavior of next is undefined if, during the traversal, you assign any value to a non-existent &#x0A;
field in the table. You may however modify existing fields. In particular, you may clear existing &#x0A;
fields. 
        ">
                <param name="table" />
                <param name="[, index]" />
            </overload>
        </keyword>
        <keyword name="nil" func="no" />
        <keyword name="not" func="no" />
        <keyword name="or" func="no" />
        <keyword name="os.clock" func="yes">
            <overload retval="void" descr="
Returns an approximation of the amount in seconds of CPU time used by the program. 
        "></overload>
        </keyword>
        <keyword name="os.date" func="yes">
            <overload retval="void" descr="
Returns a string or a table containing date and time, formatted according to the given string format.&#x0A;
&#x0A;
If the time argument is present, this is the time to be formatted (see the os.time function &#x0A;
for a description of this value). Otherwise, date formats the current time.&#x0A;
&#x0A;
If format starts with '!', then the date is formatted in Coordinated Universal Time. After this &#x0A;
optional character, if format is the string '*t', then date returns a table with the following fields: &#x0A;
year (four digits), &#x0A;
month (1--12), &#x0A;
day (1--31), &#x0A;
hour (0--23), &#x0A;
min (0--59), &#x0A;
sec (0--61), &#x0A;
wday (weekday, Sunday is 1), &#x0A;
yday (day of the year), and &#x0A;
isdst (daylight saving flag, a boolean).&#x0A;
&#x0A;
If format is not '*t', then date returns the date as a string, formatted according to the same &#x0A;
rules as the C function strftime.&#x0A;
&#x0A;
When called without arguments, date returns a reasonable date and time representation that &#x0A;
depends on the host system and on the current locale (that is, os.date() is equivalent to os.date('%c')). 
        ">
                <param name="[format [, time]]" />
            </overload>
        </keyword>
        <keyword name="os.difftime" func="yes">
            <overload retval="void" descr="
Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, &#x0A;
this value is exactly t2-t1. 
        ">
                <param name="t2" />
                <param name="t1" />
            </overload>
        </keyword>
        <keyword name="os.execute" func="yes">
            <overload retval="void" descr="
This function is equivalent to the C function system. It passes command to be executed by an operating &#x0A;
system shell. It returns a status code, which is system-dependent. If command is absent, then it returns &#x0A;
nonzero if a shell is available and zero otherwise. 
        ">
                <param name="[command]" />
            </overload>
        </keyword>
        <keyword name="os.exit" func="yes">
            <overload retval="void" descr="
Calls the C function exit, with an optional code, to terminate the host program. The default &#x0A;
value for code is the success code. 
        ">
                <param name="[code]" />
            </overload>
        </keyword>
        <keyword name="os.getenv" func="yes">
            <overload retval="void" descr="
Returns the value of the process environment variable varname, or nil if the variable is not defined. 
        ">
                <param name="varname" />
            </overload>
        </keyword>
        <keyword name="os.remove" func="yes">
            <overload retval="void" descr="
Deletes the file or directory with the given name. Directories must be empty to be removed. If this &#x0A;
function fails, it returns nil, plus a string describing the error. 
        ">
                <param name="filename" />
            </overload>
        </keyword>
        <keyword name="os.rename" func="yes">
            <overload retval="void" descr="
Renames file or directory named oldname to newname. If this function fails, it returns nil, plus a &#x0A;
string describing the error. 
        ">
                <param name="oldname" />
                <param name="newname" />
            </overload>
        </keyword>
        <keyword name="os.setlocale" func="yes">
            <overload retval="void" descr="
Sets the current locale of the program. locale is a string specifying a locale; category is an optional &#x0A;
string describing which category to change: 'all', 'collate', 'ctype', 'monetary', 'numeric', or 'time'; &#x0A;
the default category is 'all'. The function returns the name of the new locale, or nil if the request &#x0A;
cannot be honored.&#x0A;
&#x0A;
If locale is the empty string, the current locale is set to an implementation-defined native locale. If &#x0A;
locale is the string 'C', the current locale is set to the standard C locale.&#x0A;
&#x0A;
When called with nil as the first argument, this function only returns the name of the current locale &#x0A;
for the given category. 
        ">
                <param name="locale" />
                <param name="[, category]" />
            </overload>
        </keyword>
        <keyword name="os.time" func="yes">
            <overload retval="void" descr="
Returns the current time when called without arguments, or a time representing the date and time specified &#x0A;
by the given table. This table must have fields year, month, and day, and may have fields hour, min, sec, &#x0A;
and isdst (for a description of these fields, see the os.date function).&#x0A;
&#x0A;
The returned value is a number, whose meaning depends on your system. In POSIX, Windows, and some other &#x0A;
systems, this number counts the number of seconds since some given start time (the 'epoch'). &#x0A;
In other systems, the meaning is not specified, and the number returned by time can be used only as an &#x0A;
argument to date and difftime. 
        ">
                <param name="[table]" />
            </overload>
        </keyword>
        <keyword name="os.tmpname" func="yes">
            <overload retval="void" descr="
Returns a string with a file name that can be used for a temporary file. The file must be explicitly &#x0A;
opened before its use and explicitly removed when no longer needed.&#x0A;
&#x0A;
On some systems (POSIX), this function also creates a file with that name, to avoid security risks. &#x0A;
(Someone else might create the file with wrong permissions in the time between getting the name and &#x0A;
creating the file.) You still have to open the file to use it and to remove it (even if you do not use it).&#x0A;
&#x0A;
When possible, you may prefer to use io.tmpfile, which automatically removes the file when the program ends. 
        "></overload>
        </keyword>
        <keyword name="package.cpath" func="no" />
        <keyword name="package.loaded" func="no" />
        <keyword name="package.loaders" func="no" />
        <keyword name="package.loadlib" func="yes">(libname, funcname)
            <overload retval="void" descr="
Dynamically links the host program with the C library libname. Inside this library, looks for a function &#x0A;
funcname and returns this function as a C function. (So, funcname must follow the protocol (see lua_CFunction)).&#x0A;
&#x0A;
This is a low-level function. It completely bypasses the package and module system. Unlike require, it &#x0A;
does not perform any path searching and does not automatically adds extensions. libname must be the complete &#x0A;
file name of the C library, including if necessary a path and extension. funcname must be the exact name &#x0A;
exported by the C library (which may depend on the C compiler and linker used).&#x0A;
&#x0A;
This function is not supported by ANSI C. As such, it is only available on some platforms (Windows, &#x0A;
Linux, Mac OS X, Solaris, BSD, plus other Unix systems that support the dlfcn standard). 
        ">
                <param name="libname" />
                <param name="funcname" />
            </overload>
        </keyword>
        <keyword name="package.path" func="no" />
        <keyword name="package.preload" func="no" />
        <keyword name="package.seeall" func="yes">(module)
            <overload retval="void" descr="
Sets a metatable for module with its __index field referring to the global environment, so that this &#x0A;
module inherits values from the global environment. To be used as an option to function module. 
        ">
                <param name="module" />
            </overload>
        </keyword>
        <keyword name="pairs" func="yes">
            <overload retval="void" descr="
Returns three values: the next function, the table t, and nil, so that the construction&#x0A;
&#x0A;
     for k,v in pairs(t) do body end&#x0A;
&#x0A;
will iterate over all key-value pairs of table t.&#x0A;&#x0A;
&#x0A;
See function next for the caveats of modifying the table during its traversal. 
        ">
                <param name="t" />
            </overload>
        </keyword>
        <keyword name="pcall" func="yes">
            <overload retval="void" descr="
Calls function f with the given arguments in protected mode. This means that any error &#x0A;
inside f is not propagated; instead, pcall catches the error and returns a status code. &#x0A;
Its first result is the status code (a boolean), which is true if the call succeeds without &#x0A;
errors. In such case, pcall also returns all results from the call, after this first result. &#x0A;
In case of any error, pcall returns false plus the error message. 
        ">
                <param name="f" />
                <param name="arg1" />
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="print" func="yes">
            <overload retval="void" descr="
Receives any number of arguments, and prints their values to stdout, using the tostring &#x0A;
function to convert them to strings. print is not intended for formatted output, but only &#x0A;
as a quick way to show a value, typically for debugging. For formatted output, use string.format. 
        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="rawequal" func="yes">
            <overload retval="void" descr="
Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean. 
        ">
                <param name="v1" />
                <param name="v2" />
            </overload>
        </keyword>
        <keyword name="rawget" func="yes">
            <overload retval="void" descr="
Gets the real value of table[index], without invoking any metamethod. table must be a &#x0A;
table; index may be any value. 
        ">
                <param name="table" />
                <param name="index" />
            </overload>
        </keyword>
        <keyword name="rawset" func="yes">
            <overload retval="void" descr="
Sets the real value of table[index] to value, without invoking any metamethod. table must &#x0A;
be a table, index any value different from nil, and value any Lua value.

This function returns table. 
        ">
                <param name="table" />
                <param name="index" />
                <param name="value" />
            </overload>
        </keyword>
        <keyword name="repeat" func="no" />
        <keyword name="require" func="yes">
            <overload retval="void" descr="
Loads the given module. The function starts by looking into the package.loaded table to &#x0A;
determine whether modname is already loaded. If it is, then require returns the value stored &#x0A;
at package.loaded[modname]. Otherwise, it tries to find a loader for the module.&#x0A;
&#x0A;
To find a loader, require is guided by the package.loaders array. By changing this array, &#x0A;
we can change how require looks for a module. The following explanation is based on the &#x0A;
default configuration for package.loaders.&#x0A;
&#x0A;
First require queries package.preload[modname]. If it has a value, this value (which should &#x0A;
be a function) is the loader. Otherwise require searches for a Lua loader using the path &#x0A;
stored in package.path. If that also fails, it searches for a C loader using the path stored &#x0A;
in package.cpath. If that also fails, it tries an all-in-one loader (see package.loaders).&#x0A;
&#x0A;
Once a loader is found, require calls the loader with a single argument, modname. If the &#x0A;
loader returns any value, require assigns the returned value to package.loaded[modname]. &#x0A;
If the loader returns no value and has not assigned any value to package.loaded[modname], &#x0A;
then require assigns true to this entry. In any case, require returns the final value of &#x0A;
package.loaded[modname].&#x0A;
&#x0A;
If there is any error loading or running the module, or if it cannot find any loader for &#x0A;
the module, then require signals an error. 
        ">
                <param name="modname" />
            </overload>
        </keyword>
        <keyword name="return" func="no" />
        <keyword name="select" func="yes">
            <overload retval="void" descr="
If index is a number, returns all arguments after argument number index. Otherwise, index &#x0A;
must be the string '#', and select returns the total number of extra arguments it received. 
        ">
                <param name="index" />
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="setfenv" func="yes">
            <overload retval="void" descr="
Sets the environment to be used by the given function. f can be a Lua function or a number &#x0A;
that specifies the function at that stack level: Level 1 is the function calling setfenv. &#x0A;
setfenv returns the given function.&#x0A;
&#x0A;
As a special case, when f is 0 setfenv changes the environment of the running thread. &#x0A;
In this case, setfenv returns no values. 
        ">
                <param name="f" />
                <param name="table" />
            </overload>
        </keyword>
        <keyword name="setmetatable" func="yes">
            <overload retval="void" descr="
Sets the metatable for the given table. (You cannot change the metatable of other types &#x0A;
from Lua, only from C.) If metatable is nil, removes the metatable of the given table. &#x0A;
If the original metatable has a '__metatable' field, raises an error.&#x0A;
&#x0A;
This function returns table. 
        ">
                <param name="table" />
                <param name="metatable" />
            </overload>
        </keyword>
        <keyword name="string.byte" func="yes">
            <overload retval="void" descr="
Returns the internal numerical codes of the characters s[i], s[i+1], ..., s[j]. The default &#x0A;
value for i is 1; the default value for j is i.&#x0A;
&#x0A;
Note that numerical codes are not necessarily portable across platforms. 
        ">
                <param name="s [, i [, j]]" />
            </overload>
        </keyword>
        <keyword name="string.char" func="yes">
            <overload retval="void" descr="
Receives zero or more integers. Returns a string with length equal to the number of arguments, &#x0A;
in which each character has the internal numerical code equal to its corresponding argument.&#x0A;
&#x0A;
Note that numerical codes are not necessarily portable across platforms. 
        ">
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="string.dump" func="yes">
            <overload retval="void" descr="
Returns a string containing a binary representation of the given function, so that a later &#x0A;
loadstring on this string returns a copy of the function. function must be a Lua function &#x0A;
without upvalues. 
        ">
                <param name="function" />
            </overload>
        </keyword>
        <keyword name="string.find" func="yes">
            <overload retval="void" descr="
Looks for the first match of pattern in the string s. If it finds a match, then find returns &#x0A;
the indices of s where this occurrence starts and ends; otherwise, it returns nil. A third, &#x0A;
optional numerical argument init specifies where to start the search; its default value is 1 &#x0A;
and can be negative. A value of true as a fourth, optional argument plain turns off the &#x0A;
pattern matching facilities, so the function does a plain 'find substring' operation, with &#x0A;
no characters in pattern being considered 'magic'. Note that if plain is given, then init &#x0A;
must be given as well.&#x0A;
&#x0A;
If the pattern has captures, then in a successful match the captured values are also returned, &#x0A;
after the two indices. 
        ">
                <param name="s" />
                <param name="pattern" />
                <param name="[, init [, plain]]" />
            </overload>
        </keyword>
        <keyword name="string.format" func="yes">
            <overload retval="void" descr="
Returns a formatted version of its variable number of arguments following the description &#x0A;
given in its first argument (which must be a string). The format string follows the same &#x0A;
rules as the printf family of standard C functions. The only differences are that the options/modifiers &#x0A;
*, l, L, n, p, and h are not supported and that there is an extra option, q. The q option formats &#x0A;
a string in a form suitable to be safely read back by the Lua interpreter: the string is &#x0A;
written between double quotes, and all double quotes, newlines, embedded zeros, and backslashes &#x0A;
in the string are correctly escaped when written. For instance, the call&#x0A;
&#x0A;
     string.format('%q', 'a string with ''quotes'' and \n new line')&#x0A;
&#x0A;
will produce the string:&#x0A;
&#x0A;
     'a string with \''quotes\'' and \&#x0A;
      new line'&#x0A;
&#x0A;
The options c, d, E, e, f, g, G, i, o, u, X, and x all expect a number as argument, whereas &#x0A;
q and s expect a string.&#x0A;
&#x0A;
This function does not accept string values containing embedded zeros, except as arguments &#x0A;
to the q option. 
        ">
                <param name="formatstring" />
                <param name="..." />
            </overload>
        </keyword>
        <keyword name="string.gmatch" func="yes">
            <overload retval="void" descr="
Returns an iterator function that, each time it is called, returns the next captures from &#x0A;
pattern over string s. If pattern specifies no captures, then the whole match is produced &#x0A;
in each call.&#x0A;
&#x0A;
As an example, the following loop&#x0A;
&#x0A;
     s = 'hello world from Lua'&#x0A;
     for w in string.gmatch(s, '%a+') do&#x0A;
       print(w)&#x0A;
     end&#x0A;
&#x0A;
will iterate over all the words from string s, printing one per line. The next example collects &#x0A;
all pairs key=value from the given string into a table:&#x0A;
&#x0A;
     t = {}&#x0A;
     s = 'from=world, to=Lua'&#x0A;
     for k, v in string.gmatch(s, '(%w+)=(%w+)') do&#x0A;
       t[k] = v&#x0A;
     end&#x0A;
&#x0A;
For this function, a '^' at the start of a pattern does not work as an anchor, as this would &#x0A;
prevent the iteration. 
        ">
                <param name="s" />
                <param name="pattern" />
            </overload>
        </keyword>
        <keyword name="string.gsub" func="yes">
            <overload retval="void" descr="
Returns a copy of s in which all (or the first n, if given) occurrences of the pattern have &#x0A;
been replaced by a replacement string specified by repl, which can be a string, a table, or &#x0A;
a function. gsub also returns, as its second value, the total number of matches that occurred.&#x0A;
&#x0A;
Look at the online documentation for this function.
">
                <param name="s" />
                <param name="pattern" />
                <param name="repl" />
                <param name="[, n]" />
            </overload>
        </keyword>
        <keyword name="string.len" func="yes">
            <overload retval="void" descr="
Receives a string and returns its length. The empty string '' has length 0. Embedded zeros are &#x0A;
counted, so 'a\000bc\000' has length 5. 
        ">
                <param name="s" />
            </overload>
        </keyword>
        <keyword name="string.lower" func="yes">
            <overload retval="void" descr="
Receives a string and returns a copy of this string with all uppercase letters changed to &#x0A;
lowercase. All other characters are left unchanged. The definition of what an uppercase &#x0A;
letter is depends on the current locale. 
        ">
                <param name="s" />
            </overload>
        </keyword>
        <keyword name="string.match" func="yes">
            <overload retval="void" descr="
Looks for the first match of pattern in the string s. If it finds one, then match returns the &#x0A;
captures from the pattern; otherwise it returns nil. If pattern specifies no captures, then &#x0A;
the whole match is returned. A third, optional numerical argument init specifies where to &#x0A;
start the search; its default value is 1 and can be negative. 
        ">
                <param name="s" />
                <param name="pattern" />
                <param name="[, init]" />
            </overload>
        </keyword>
        <keyword name="string.rep" func="yes">
            <overload retval="void" descr="
Returns a string that is the concatenation of n copies of the string s. 
        ">
                <param name="s" />
                <param name="n" />
            </overload>
        </keyword>
        <keyword name="string.reverse" func="yes">
            <overload retval="void" descr="
Returns a string that is the string s reversed. 
        ">
                <param name="s" />
            </overload>
        </keyword>
        <keyword name="string.sub" func="yes">
            <overload retval="void" descr="
Returns the substring of s that starts at i and continues until j; i and j can be negative. &#x0A;
If j is absent, then it is assumed to be equal to -1 (which is the same as the string length). &#x0A;
In particular, the call string.sub(s,1,j) returns a prefix of s with length j, and string.sub(s, -i) &#x0A;
returns a suffix of s with length i. 
        ">
                <param name="s" />
                <param name="i" />
                <param name="[, j]" />
            </overload>
        </keyword>
        <keyword name="string.upper" func="yes">
            <overload retval="void" descr="
Receives a string and returns a copy of this string with all lowercase letters changed to &#x0A;
uppercase. All other characters are left unchanged. The definition of what a lowercase letter &#x0A;
is depends on the current locale. 
        ">
                <param name="s" />
            </overload>
        </keyword>
        <keyword name="table.concat" func="yes">
            <overload retval="void" descr="
Given an array where all elements are strings or numbers, returns table[i]..sep..table[i+1] ... sep..table[j]. &#x0A;
The default value for sep is the empty string, the default for i is 1, and the default for j is the length &#x0A;
of the table. If i is greater than j, returns the empty string. 
        ">
                <param name="table" />
                <param name="[, sep [, i [, j]]]" />
            </overload>
        </keyword>
        <keyword name="table.insert" func="yes">
            <overload retval="void" descr="
Inserts element value at position pos in table, shifting up other elements to open space, &#x0A;
if necessary. The default value for pos is n+1, where n is the length of the table, &#x0A;
so that a call table.insert(t,x) inserts x at the end of table t. 
        ">
                <param name="table" />
                <param name="[pos,]" />
                <param name="value" />
            </overload>
        </keyword>
        <keyword name="table.maxn" func="yes">
            <overload retval="void" descr="
Returns the largest positive numerical index of the given table, or zero if the table has no &#x0A;
positive numerical indices. (To do its job this function does a linear traversal of the whole table.) 
        ">
                <param name="table" />
            </overload>
        </keyword>
        <keyword name="table.remove" func="yes">
            <overload retval="void" descr="
Removes from table the element at position pos, shifting down other elements to close the space, &#x0A;
if necessary. Returns the value of the removed element. The default value for pos is n, where n &#x0A;
is the length of the table, so that a call table.remove(t) removes the last element of table t. 
        ">
                <param name="table" />
                <param name="[, pos]" />
            </overload>
        </keyword>
        <keyword name="table.sort" func="yes">
            <overload retval="void" descr="
Sorts table elements in a given order, in-place, from table[1] to table[n], where n is the length &#x0A;
of the table. If comp is given, then it must be a function that receives two table elements, and &#x0A;
returns true when the first is less than the second (so that not comp(a[i+1],a[i]) will be true &#x0A;
after the sort). If comp is not given, then the standard Lua operator lessthan is used instead.&#x0A;
&#x0A;
The sort algorithm is not stable; that is, elements considered equal by the given order may have &#x0A;
their relative positions changed by the sort. 
        ">
                <param name="table" />
                <param name="[, comp]" />
            </overload>
        </keyword>
        <keyword name="then" func="no" />
        <keyword name="tonumber" func="yes">
            <overload retval="void" descr="
Tries to convert its argument to a number. If the argument is already a number or a string &#x0A;
convertible to a number, then tonumber returns this number; otherwise, it returns nil.&#x0A;
&#x0A;
An optional argument specifies the base to interpret the numeral. The base may be any integer &#x0A;
between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) &#x0A;
represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. In base 10 (the default), &#x0A;
the number can have a decimal part, as well as an optional exponent part. In other &#x0A;
bases, only unsigned integers are accepted. 
        ">
                <param name="e" />
                <param name="[, base]" />
            </overload>
        </keyword>
        <keyword name="tostring" func="yes">
            <overload retval="void" descr="
Receives an argument of any type and converts it to a string in a reasonable format. For complete &#x0A;
control of how numbers are converted, use string.format.&#x0A;
&#x0A;
If the metatable of e has a '__tostring' field, then tostring calls the corresponding value with &#x0A;
e as argument, and uses the result of the call as its result. 
        ">
                <param name="e" />
            </overload>
        </keyword>
        <keyword name="true" func="no" />
        <keyword name="type" func="yes">
            <overload retval="void" descr="
Returns the type of its only argument, coded as a string. The possible results of this function &#x0A;
are 'nil' (a string, not the value nil), 'number', 'string', 'boolean', 'table', 'function', 'thread', and 'userdata'. 
        ">
                <param name="v" />
            </overload>
        </keyword>
        <keyword name="unpack" func="yes">
            <overload retval="void" descr="
Returns the elements from the given table. This function is equivalent to&#x0A;
&#x0A;
     return list[i], list[i+1], ..., list[j]&#x0A;
&#x0A;
except that the above code can be written only for a fixed number of elements. By default, i is 1 and &#x0A;
j is the length of the list, as defined by the length operator. 
        ">
                <param name="list" />
                <param name="[, i [, j]]" />
            </overload>
        </keyword>
        <keyword name="until" func="no" />
        <keyword name="while" func="no" />
        <keyword name="xpcall" func="yes">
            <overload retval="void" descr="
This function is similar to pcall, except that you can set a new error handler.&#x0A;
&#x0A;
xpcall calls function f in protected mode, using err as the error handler. Any error inside f is &#x0A;
not propagated; instead, xpcall catches the error, calls the err function with the original error &#x0A;
object, and returns a status code. Its first result is the status code (a boolean), which is true &#x0A;
if the call succeeds without errors. In this case, xpcall also returns all results from the call, &#x0A;
after this first result. In case of any error, xpcall returns false plus the result from err. 
        ">
                <param name="f" />
                <param name="err" />
            </overload>
        </keyword>
        <!-- Globals -->
        <keyword name="_G" />
        <keyword name="assert()" />
        <keyword name="error()" />
        <keyword name="getfenv()" />
        <keyword name="getmetatable()" />
        <keyword name="pairs()" />
        <keyword name="ipairs()" />
        <keyword name="pcall()" />
        <keyword name="xpcall()" />
        <keyword name="print()" />
        <keyword name="rawequal()" />
        <keyword name="rawget()" />
        <keyword name="rawset()" />
        <keyword name="require()" />
        <keyword name="select()" />
        <keyword name="setfenv()" />
        <keyword name="setmetatable()" />
        <keyword name="gcinfo()" />
        <keyword name="tonumber()" />
        <keyword name="tostring()" />
        <keyword name="type()" />
        <keyword name="unpack()" />
        <keyword name="module()" />
        <keyword name="next()" />
        <keyword name="_VERSION" />
        <keyword name="collectgarbage()" />
        <keyword name="dofile()" />
        <!-- bit -->
        <keyword name="bit.rol()" />
        <keyword name="bit.rshift()" />
        <keyword name="bit.ror()" />
        <keyword name="bit.bswap()" />
        <keyword name="bit.bxor()" />
        <keyword name="bit.bor()" />
        <keyword name="bit.arshift()" />
        <keyword name="bit.bnot()" />
        <keyword name="bit.tobit()" />
        <keyword name="bit.lshift()" />
        <keyword name="bit.tohex()" />
        <keyword name="bit.band()" />
        <!-- coroutine -->
        <keyword name="coroutine.wrap()" />
        <keyword name="coroutine.yield()" />
        <keyword name="coroutine.resume()" />
        <keyword name="coroutine.status()" />
        <keyword name="coroutine.isyieldable()" />
        <keyword name="coroutine.running()" />
        <keyword name="coroutine.create()" />
        <!-- debug -->
        <keyword name="debug.debug()" />
        <keyword name="debug.gethook()" />
        <keyword name="debug.getinfo()" />
        <keyword name="debug.getlocal()" />
        <keyword name="debug.getmetatable()" />
        <keyword name="debug.getregistry()" />
        <keyword name="debug.getupvalue()" />
        <keyword name="debug.getuservalue()" />
        <keyword name="debug.sethook()" />
        <keyword name="debug.setmetatable()" />
        <keyword name="debug.setupvalue()" />
        <keyword name="debug.setuservalue()" />
        <keyword name="debug.traceback()" />
        <keyword name="debug.upvalueid()" />
        <keyword name="debug.upvaluejoin()" />
        <keyword name="io.close()" />
        <keyword name="io.flush()" />
        <keyword name="io.input()" />
        <keyword name="io.lines()" />
        <keyword name="io.open()" />
        <keyword name="io.output()" />
        <keyword name="io.read()" />
        <keyword name="io.tmpfile()" />
        <keyword name="io.type()" />
        <keyword name="io.write()" />
        <keyword name="io.stdin" />
        <keyword name="io.stdout" />
        <keyword name="io.stderr" />
        <keyword name="math.abs()" />
        <keyword name="math.acos()" />
        <keyword name="math.asin()" />
        <keyword name="math.atan()" />
        <keyword name="math.atan2()" />
        <keyword name="math.ceil()" />
        <keyword name="math.cos()" />
        <keyword name="math.cosh()" />
        <keyword name="math.deg()" />
        <keyword name="math.exp()" />
        <keyword name="math.floor()" />
        <keyword name="math.fmod()" />
        <keyword name="math.frexp()" />
        <keyword name="math.huge" />
        <keyword name="math.ldexp()" />
        <keyword name="math.log()" />
        <keyword name="math.log10()" />
        <keyword name="math.max()" />
        <keyword name="math.min()" />
        <keyword name="math.modf()" />
        <keyword name="math.pi" />
        <keyword name="math.pow()" />
        <keyword name="math.rad()" />
        <keyword name="math.random()" />
        <keyword name="math.randomseed()" />
        <keyword name="math.round()" />
        <keyword name="math.sin()" />
        <keyword name="math.sinh()" />
        <keyword name="math.sqrt()" />
        <keyword name="math.tan()" />
        <keyword name="math.tanh()" />
        <keyword name="os.clock()" />
        <keyword name="os.date()" />
        <keyword name="os.difftime()" />
        <keyword name="os.execute()" />
        <keyword name="os.exit()" />
        <keyword name="os.remove()" />
        <keyword name="os.rename()" />
        <keyword name="os.time()" />
        <keyword name="os.setlocal()" />
        <keyword name="os.getenv()" />
        <keyword name="os.tmpname()" />
        <keyword name="package.config" />
        <keyword name="package.loaded" />
        <keyword name="package.loaders" />
        <keyword name="package.seeall()" />
        <keyword name="package.loadlib()" />
        <keyword name="package.preload" />
        <keyword name="package.cpath" />
        <keyword name="package.searchpath" />
        <keyword name="string.byte()" />
        <keyword name="string.char()" />
        <keyword name="string.dump()" />
        <keyword name="string.find()" />
        <keyword name="string.format()" />
        <keyword name="string.gmatch()" />
        <keyword name="string.gsub()" />
        <keyword name="string.len()" />
        <keyword name="string.lower()" />
        <keyword name="string.match()" />
        <keyword name="string.rep()" />
        <keyword name="string.reverse()" />
        <keyword name="string.sub()" />
        <keyword name="string.upper()" />
        <keyword name="table.concat()" />
        <keyword name="table.insert()" />
        <keyword name="table.move()" />
        <!--<keyword name="table.pack()" />-->
        <keyword name="table.remove()" />
        <keyword name="table.sort()" />
        <!--<keyword name="table.unpack()" />-->
        <keyword name="table.maxn()" />
        <keyword name="table.foreach()" />
        <keyword name="table.foreachi()" />
        <keyword name="table.getn()" />
        <keyword name="cjson.decode()" />
        <keyword name="cjson.decode_invalid_numbers()" />
        <keyword name="cjson.decode_max_depth()" />
        <keyword name="cjson.encode()" />
        <keyword name="cjson.encode_invalid_numbers()" />
        <keyword name="cjson.encode_keep_buffer()" />
        <keyword name="cjson.encode_max_depth()" />
        <keyword name="cjson.encode_number_precision()" />
        <keyword name="cjson.encode_sparse_array()" />
        <keyword name="crypto.digest()" />
        <keyword name="crypto.hmac()" />
        <keyword name="crypto.md4" />
        <keyword name="crypto.md5" />
        <keyword name="crypto.sha1" />
        <keyword name="crypto.sha224" />
        <keyword name="crypto.sha256" />
        <keyword name="crypto.sha384" />
        <keyword name="crypto.sha512" />
    </autoc>
</api-cfg>