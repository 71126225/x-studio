-- This file is generated by x-studio Pro 10.0.9000.122 Â© 2021, All rights reserved.
local editor_spec = require('editor_spec')
local function processSelection(editor, func)
    local text = editor:GetSelectedText()
    local line = editor:GetCurrentLine()
    local posinline = editor:GetCurrentPos() - editor:PositionFromLine(line)
    if #text == 0 then
        editor:SelectAll()
        text = editor:GetSelectedText()
    end
    local wholeline = text:find("\n$")
    local buf = {}
    for ln in string.gmatch(text..(wholeline and "" or "\n"), "(.-\r?\n)") do
        table.insert(buf, ln)
    end

    editor:SaveDocumentPosition();

    if #buf > 0 then
        if func then func(buf) end
        -- add new line at the end if it was there
        local newtext = table.concat(buf, ""):gsub("(\r?\n)$", wholeline and "%1" or "")
        -- straightforward editor:ReplaceSelection() doesn't work reliably as
        -- it sometimes doubles the context when the entire file is selected.
        -- this seems like Scintilla issue, so use ReplaceTarget instead.
        -- One reason why ReplaceSelection() may not work is the presence of
        -- hidden characters (for example, in the hidden markdown markup).
        -- Since this doesn't work with rectangular selection, which
        -- ReplaceSelection should handle (after wxwidgets 3.x upgrade), this
        -- will need to be revisited when ReplaceSelection is updated.
        if newtext ~= text then
            editor:BeginUndoAction()
            -- if there is at least one marker, then use a different mechanism to preserve them
            -- simply saving markers, replacing text, and reapplying markers doesn't work as
            -- they get reset after `undo/redo` operations.
            -- local ssel, esel = editor:GetSelectionStart(), editor:GetSelectionEnd()
            -- local sline = editor:LineFromPosition(ssel)
            -- local eline = editor:LineFromPosition(esel)
            -- if #editor:MarkerGetAll(nil, sline, eline) > 0 then
            --   for line = #buf, 1, -1 do
            --     editor:SetTargetStart(line == 1 and ssel or editor:PositionFromLine(sline+line-1))
            --     editor:SetTargetEnd(line == eline-sline+1 and esel or editor:GetLineEndPosition(sline+line-1))
            --     editor:ReplaceTarget((buf[line]:gsub("\r?\n$", "")))
            --   end
            -- else
            editor:TargetFromSelection()
            editor:ReplaceTarget(newtext)
            -- end
            editor:EndUndoAction()
        end
    end

    local caretPos = math.min(editor:PositionFromLine(line)+posinline, editor:GetLineEndPosition(line))

    editor:RestoreDocumentPosition(caretPos) -- editor:GotoPosEnforcePolicy(caretPos)
end

local function reIndent(editor, buf)
    local decindent, incindent = editor.spec.isdecindent, editor.spec.isincindent
    if not (decindent and incindent) then return end

    local edline = editor:LineFromPosition(editor:GetSelectionStart())
    local indent = 0
    local text = ""
    -- find the last non-empty line in the previous block (if any)
    for n = edline-1, 1, -1 do
        indent = editor:GetLineIndentation(n)
        text = editor:GetLineDyn(n)
        if text:match("[^\r\n]") then break end
    end

    local ut = editor:GetUseTabs()
    local tw = ut and editor:GetTabWidth() or editor:GetIndent()

    local indents = {}
    local isstatic = {}
    for line = 1, #buf+1 do
        local ls = editor:PositionFromLine(edline+line-1)
        local style = (editor:GetStyleAt(ls) & 255)
        -- don't reformat multi-line comments or strings
        isstatic[line] = (editor.spec.iscomment[style]
            or editor.spec.isstring[style])
        if not isstatic[line] or line == 1 or not isstatic[line-1] then
            local closed, blockend = decindent(text)
            local opened = incindent(text)

            -- ignore impact from initial block endings as they are already indented
            if line == 1 then blockend = 0 end

            -- this only needs to be done for 2, #buf+1; do it and get out when done
            if line > 1 then indents[line-1] = indents[line-1] - tw * closed end
            if line > #buf then break end

            indent = indent + tw * (opened - blockend)
            if indent < 0 then indent = 0 end
        end

        indents[line] = indent
        text = buf[line]
    end

    for line = 1, #buf do
        if not isstatic[line] then
            buf[line] = buf[line]:gsub("^[ \t]*",
                not buf[line]:match("%S") and ""
                or ut and ("\t"):rep(indents[line] / tw) or (" "):rep(indents[line]))
        end
    end
end

local function correctIndent(editor)
    if editor.spec == nil then
        editor.spec = editor_spec
    end
    processSelection(editor, function(buf) reIndent(editor, buf) end)
end

dzsft.correctIndent = correctIndent

EditorLogD("init editor_ext ok.");

return correctIndent;
